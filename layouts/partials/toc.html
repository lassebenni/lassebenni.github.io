{{- $headers := findRE "<h[1-6].*?>(.|\n])+?</h[1-6]>" .Content -}}
{{- $h1headers := findRE "<h1.*?>(.|\n])+?</h1>" .Content -}}
{{- $has_headers := ge (len $headers) 1 -}}
{{- $has_h1headers := ge (len $h1headers) 1 -}}
<div class="toc">
    <details {{if (.Param "TocOpen") }} open{{ end }}>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">{{- i18n "toc" | default "Table of Contents" }}</span>
        </summary>

        <div class="inner">
            {{- if (.Param "UseHugoToc") }}
            {{- .TableOfContents -}}
            {{- else }}
            {{- $largest := 6 -}}
            {{- range $headers -}}
            {{- $headerLevel := index (findRE "[1-6]" . 1) 0 -}}
            {{- $headerLevel := len (seq $headerLevel) -}}
            {{- if lt $headerLevel $largest -}}
            {{- $largest = $headerLevel -}}
            {{- end -}}
            {{- end -}}

            {{- $firstHeaderLevel := len (seq (index (findRE "[1-6]" (index $headers 0) 1) 0)) -}}

            {{- $.Scratch.Set "bareul" slice -}}
            <ul>
                {{- range seq (sub $firstHeaderLevel $largest) -}}
                <ul>
                    {{- $.Scratch.Add "bareul" (sub (add $largest .) 1) -}}
                    {{- end -}}
                    {{- range $i, $header := $headers -}}
                    {{- $headerLevel := index (findRE "[1-6]" . 1) 0 -}}
                    {{- $headerLevel := len (seq $headerLevel) -}}

                    {{/* get id="xyz" */}}
                    {{- $id := index (findRE "(id=\"(.*?)\")" $header 9) 0 }}

                    {{- /* strip id="" to leave xyz, no way to get regex capturing groups in hugo */ -}}
                    {{- $cleanedID := replace (replace $id "id=\"" "") "\"" "" }}
                    {{- $header := replaceRE "<h[1-6].*?>((.|\n])+?)</h[1-6]>" "$1" $header -}}

                    {{- if ne $i 0 -}}
                    {{- $prevHeaderLevel := index (findRE "[1-6]" (index $headers (sub $i 1)) 1) 0 -}}
                    {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}}
                    {{- if gt $headerLevel $prevHeaderLevel -}}
                    {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}}
                    <ul>
                        {{/* the first should not be recorded */}}
                        {{- if ne $prevHeaderLevel . -}}
                        {{- $.Scratch.Add "bareul" . -}}
                        {{- end -}}
                        {{- end -}}
                        {{- else -}}
                        </li>
                        {{- if lt $headerLevel $prevHeaderLevel -}}
                        {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}}
                        {{- if in ($.Scratch.Get "bareul") . -}}
                    </ul>
                    {{/* manually do pop item */}}
                    {{- $tmp := $.Scratch.Get "bareul" -}}
                    {{- $.Scratch.Delete "bareul" -}}
                    {{- $.Scratch.Set "bareul" slice}}
                    {{- range seq (sub (len $tmp) 1) -}}
                    {{- $.Scratch.Add "bareul" (index $tmp (sub . 1)) -}}
                    {{- end -}}
                    {{- else -}}
                </ul>
                </li>
                {{- end -}}
                {{- end -}}
                {{- end -}}
                {{- end }}
                <li>
                    <a href="#{{- $cleanedID -}}" aria-label="{{- $header | plainify | safeHTML -}}">{{- $header | plainify | safeHTML -}}</a>
                    {{- else }}
                <li>
                    <a href="#{{- $cleanedID -}}" aria-label="{{- $header | plainify | safeHTML -}}">{{- $header | plainify | safeHTML -}}</a>
                    {{- end -}}
                    {{- end -}}
                    <!-- {{- $firstHeaderLevel := len (seq (index (findRE "[1-6]" (index $headers 0) 1) 0)) -}} -->
                    {{- $firstHeaderLevel := $largest }}
                    {{- $lastHeaderLevel := len (seq (index (findRE "[1-6]" (index $headers (sub (len $headers) 1)) 1) 0)) }}
                </li>
                {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}}
                {{- if in ($.Scratch.Get "bareul") (add . $firstHeaderLevel) }}
            </ul>
            {{- else }}
            </ul>
            </li>
            {{- end -}}
            {{- end }}
            </ul>
            {{- end }}
        </div>
    </details>
</div>

<script>
// Active link alignment and correct anchor scrolling under sticky header
document.addEventListener('DOMContentLoaded', function () {
  const toc = document.querySelector('.toc');
  const tocSidebar = document.getElementById('toc-sidebar') || toc;

  const tocLinks = toc ? toc.querySelectorAll('a[href^="#"]') : [];
  const headerAnchors = document.querySelectorAll('.post-content a.anchor[href^="#"]');

  function getHeaderOffset() {
    // Prefer unified CSS var for anchor offset
    const offRaw = getComputedStyle(document.documentElement).getPropertyValue('--anchor-offset').trim();
    let off = parseInt(offRaw, 10);
    if (!Number.isNaN(off)) return off;

    // Fallback: header height plus additional breathing room
    const raw = getComputedStyle(document.documentElement).getPropertyValue('--header-height').trim();
    let h = parseInt(raw, 10);
    if (Number.isNaN(h)) h = 64;

    const extraRaw = getComputedStyle(document.documentElement).getPropertyValue('--anchor-extra-offset').trim();
    let extra = parseInt(extraRaw, 10);
    if (Number.isNaN(extra)) extra = 24;

    return h + extra;
  }

  function scrollToId(id, smooth = true) {
    const target = document.getElementById(id);
    if (!target) return;
    const top = window.scrollY + target.getBoundingClientRect().top - getHeaderOffset();
    window.scrollTo({ top, behavior: smooth ? 'smooth' : 'auto' });
  }

  // Build headers list for active-link tracking when ToC exists
  const headers = tocLinks && tocLinks.length
    ? Array.from(tocLinks).map(a => document.getElementById(a.getAttribute('href').slice(1))).filter(Boolean)
    : [];

  function updateActive() {
    if (!headers.length || !toc) return;
    const offset = getHeaderOffset();
    let active = headers[0];

    for (let i = 0; i < headers.length; i++) {
      const rect = headers[i].getBoundingClientRect();
      if (rect.top - offset <= 0) active = headers[i];
      else break;
    }

    tocLinks.forEach(a => a.classList.remove('active'));
    if (active) {
      const link = toc.querySelector(`a[href="#${active.id}"]`);
      if (link) {
        link.classList.add('active');
        // keep active link in view inside the sidebar
        const c = tocSidebar || document.scrollingElement;
        if (c && c.scrollTop !== undefined) {
          const linkTop = link.offsetTop;
          const linkBottom = linkTop + link.offsetHeight;
          if (linkTop < c.scrollTop) c.scrollTop = linkTop;
          else if (linkBottom > c.scrollTop + c.clientHeight) c.scrollTop = linkBottom - c.clientHeight;
        }
      }
    }
  }

  // ToC link clicks with sticky-header compensation
  (tocLinks || []).forEach(a => {
    a.addEventListener('click', function (e) {
      e.preventDefault();
      const id = this.getAttribute('href').slice(1);
      scrollToId(id, true);
      history.pushState(null, '', '#' + id);
    });
  });

  // BEST PRACTICE: also compensate when clicking the small "#" heading anchors in content
  headerAnchors.forEach(a => {
    a.addEventListener('click', function (e) {
      e.preventDefault();
      const id = this.getAttribute('href').slice(1);
      scrollToId(id, true);
      history.pushState(null, '', '#' + id);
    });
  });

  // Handle initial load with hash and subsequent hash changes (e.g., external links)
  function adjustForCurrentHash() {
    if (location.hash && location.hash.length > 1) {
      const id = decodeURIComponent(location.hash.slice(1));
      // Use a tick to allow native jump then correct offset
      setTimeout(() => scrollToId(id, false), 0);
    }
  }
  adjustForCurrentHash();
  window.addEventListener('hashchange', adjustForCurrentHash);

  updateActive();
  window.addEventListener('scroll', updateActive, { passive: true });
});
</script>