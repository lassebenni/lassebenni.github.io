{{- $headers := findRE "<h[1-6].*?>(.|\n])+?</h[1-6]>" .Content -}}
{{- $h1headers := findRE "<h1.*?>(.|\n])+?</h1>" .Content -}}
{{- $has_headers := ge (len $headers) 1 -}}
{{- $has_h1headers := ge (len $h1headers) 1 -}}
<div class="toc">
    <details {{if (.Param "TocOpen") }} open{{ end }}>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">{{- i18n "toc" | default "Table of Contents" }}</span>
        </summary>

        <div class="inner">
            {{- if (.Param "UseHugoToc") }}
            {{- .TableOfContents -}}
            {{- else }}
            {{- $largest := 6 -}}
            {{- range $headers -}}
            {{- $headerLevel := index (findRE "[1-6]" . 1) 0 -}}
            {{- $headerLevel := len (seq $headerLevel) -}}
            {{- if lt $headerLevel $largest -}}
            {{- $largest = $headerLevel -}}
            {{- end -}}
            {{- end -}}

            {{- $firstHeaderLevel := len (seq (index (findRE "[1-6]" (index $headers 0) 1) 0)) -}}

            {{- $.Scratch.Set "bareul" slice -}}
            <ul>
                {{- range seq (sub $firstHeaderLevel $largest) -}}
                <ul>
                    {{- $.Scratch.Add "bareul" (sub (add $largest .) 1) -}}
                    {{- end -}}
                    {{- range $i, $header := $headers -}}
                    {{- $headerLevel := index (findRE "[1-6]" . 1) 0 -}}
                    {{- $headerLevel := len (seq $headerLevel) -}}

                    {{/* get id="xyz" */}}
                    {{- $id := index (findRE "(id=\"(.*?)\")" $header 9) 0 }}

                    {{- /* strip id="" to leave xyz, no way to get regex capturing groups in hugo */ -}}
                    {{- $cleanedID := replace (replace $id "id=\"" "") "\"" "" }}
                    {{- $header := replaceRE "<h[1-6].*?>((.|\n])+?)</h[1-6]>" "$1" $header -}}

                    {{- if ne $i 0 -}}
                    {{- $prevHeaderLevel := index (findRE "[1-6]" (index $headers (sub $i 1)) 1) 0 -}}
                    {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}}
                    {{- if gt $headerLevel $prevHeaderLevel -}}
                    {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}}
                    <ul>
                        {{/* the first should not be recorded */}}
                        {{- if ne $prevHeaderLevel . -}}
                        {{- $.Scratch.Add "bareul" . -}}
                        {{- end -}}
                        {{- end -}}
                        {{- else -}}
                        </li>
                        {{- if lt $headerLevel $prevHeaderLevel -}}
                        {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}}
                        {{- if in ($.Scratch.Get "bareul") . -}}
                    </ul>
                    {{/* manually do pop item */}}
                    {{- $tmp := $.Scratch.Get "bareul" -}}
                    {{- $.Scratch.Delete "bareul" -}}
                    {{- $.Scratch.Set "bareul" slice}}
                    {{- range seq (sub (len $tmp) 1) -}}
                    {{- $.Scratch.Add "bareul" (index $tmp (sub . 1)) -}}
                    {{- end -}}
                    {{- else -}}
                </ul>
                </li>
                {{- end -}}
                {{- end -}}
                {{- end -}}
                {{- end }}
                <li>
                    <a href="#{{- $cleanedID -}}" aria-label="{{- $header | plainify | safeHTML -}}">{{- $header | plainify | safeHTML -}}</a>
                    {{- else }}
                <li>
                    <a href="#{{- $cleanedID -}}" aria-label="{{- $header | plainify | safeHTML -}}">{{- $header | plainify | safeHTML -}}</a>
                    {{- end -}}
                    {{- end -}}
                    <!-- {{- $firstHeaderLevel := len (seq (index (findRE "[1-6]" (index $headers 0) 1) 0)) -}} -->
                    {{- $firstHeaderLevel := $largest }}
                    {{- $lastHeaderLevel := len (seq (index (findRE "[1-6]" (index $headers (sub (len $headers) 1)) 1) 0)) }}
                </li>
                {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}}
                {{- if in ($.Scratch.Get "bareul") (add . $firstHeaderLevel) }}
            </ul>
            {{- else }}
            </ul>
            </li>
            {{- end -}}
            {{- end }}
            </ul>
            {{- end }}
        </div>
    </details>
</div>

<script>
// Active link alignment that accounts for sticky header height and smooth-scroll offset
document.addEventListener('DOMContentLoaded', function () {
  const toc = document.querySelector('.toc');
  if (!toc) return;

  const tocSidebar = document.getElementById('toc-sidebar') || toc;
  const links = toc.querySelectorAll('a[href^="#"]');
  if (!links.length) return;

  const headers = Array.from(links)
    .map(a => document.getElementById(a.getAttribute('href').slice(1)))
    .filter(Boolean);

  function getHeaderOffset() {
    // Read CSS var --header-height, fallback to 64px, add small breathing room
    const raw = getComputedStyle(document.documentElement).getPropertyValue('--header-height').trim();
    let h = parseInt(raw, 10);
    if (Number.isNaN(h)) h = 64;
    return h + 12;
  }

  function updateActive() {
    const offset = getHeaderOffset();
    let active = headers[0];

    // choose the last header whose top is above the offset line
    for (let i = 0; i < headers.length; i++) {
      const rect = headers[i].getBoundingClientRect();
      if (rect.top - offset <= 0) active = headers[i];
      else break;
    }

    links.forEach(a => a.classList.remove('active'));
    if (active) {
      const link = toc.querySelector(`a[href="#${active.id}"]`);
      if (link) {
        link.classList.add('active');
        // keep active link in view inside the sidebar
        const c = tocSidebar;
        const linkTop = link.offsetTop;
        const linkBottom = linkTop + link.offsetHeight;
        if (linkTop < c.scrollTop) c.scrollTop = linkTop;
        else if (linkBottom > c.scrollTop + c.clientHeight) c.scrollTop = linkBottom - c.clientHeight;
      }
    }
  }

  // Smooth scroll that compensates for sticky header
  links.forEach(a => {
    a.addEventListener('click', function (e) {
      e.preventDefault();
      const id = this.getAttribute('href').slice(1);
      const target = document.getElementById(id);
      if (!target) return;

      const offset = getHeaderOffset();
      const top = window.scrollY + target.getBoundingClientRect().top - offset;
      window.scrollTo({ top, behavior: 'smooth' });
      history.pushState(null, '', '#' + id);
    });
  });

  updateActive();
  window.addEventListener('scroll', updateActive, { passive: true });
});
</script>